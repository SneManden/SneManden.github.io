{"slug":"wavefront-implementation","html":"<p>En stille torsdag aften blev pludselig dedikeret til implementeringen af\nwavefront algoritmen til at finde korteste vej gennem et diskret arbejdsrum\nmed forhindringer; dvs. fx en labyrint repræsenteret i et billede.</p>\n<h2 id=\"specifikation\">Specifikation</h2>\n<p>Mikkel, robotteknologi-studerende, havde i et kursus fået en sjov lille opgave;\nde skulle implementere wavefront algoritmen i <code>C++</code> og finde den korteste vej\ngennem en labyrint i en billedefil ud fra et start og ende punkt.\nJeg syntes opgaven lød meget sjov, så jeg valgte at lave min egen implementering\ni <code>C</code>.</p>\n<p><a href=\"/static/media/labyrinth.pgm\"><img src=\"/static/media/labyrinth.png\" alt=\"Korteste vej\" style=\"display:block;width:50%;margin:0 auto;\"></a></p>\n<p>Den udleverede labyrint er repræsenteret som en <code>.pgm</code> fil: et\n<a href=\"http://netpbm.sourceforge.net/doc/pgm.html\" target=\"_blank\" rel=\"noopener noreferrer\">simpelt gråtone billedeformat</a>.\nDet indeholder et &quot;magisk nummer&quot; (version/format), bredde, højde og maxværdi\nfor gråtone. Dernæst følger $\\text{bredde} \\cdot \\text{højde}$ værdier\nrepræsenterende den $i$te pixels gråtone: $0=\\text{sort}$, $maxval=\\text{hvid}$.\n($i$te pixel fra øverste venstre til nederste højre hjørne.)</p>\n<h2 id=\"design\">Design</h2>\n<p>Programmet starter med at parse billedefilen; læse headeren og dernæst opbygge\net lineært array af $\\text{bredde} \\cdot \\text{højde}$ punkter; som alt efter\nden valgte tolerance får værdien $0$ hvis pixlen er fri eller $1$ hvis det er\nen forhindring.\nHvert punkt har også et array på fire <code>integers</code> repræsenterende index&#39;et til\npunktets naboer (forstået som en pointer). </p>\n<p>Dernæst udføres wavefront algoritmen. Pseudokoden for min implementering er</p>\n<pre><code>wavefront(image, start, slut)\n    skridt = 0\n    queue = ny tom kø\n    læg slut-punktet i queue og tildel det værdien 2\n\n    while (køen har elementer)\n        elm = udtræk første element i køen\n        for (hver nabo til elm)\n            if (nabo findes OG nabo er fri)\n                nabo.value = elm.value + 1\n                læg nabo i køen\n        skridt = skridt+1\n    return skridt</code></pre>\n<p>Køretiden for denne algoritme er $O(n\\cdot m)$ for $n=\\text{bredde}$ og\n$m=\\text{højde}$ af billedet.</p>\n<p>Når wavefront algoritmen er anvendt på billedet, findes den korteste vej nemt,\nved blot at starte i start-punktet, og følge stien til mål ved at gå i den\nretning som har mindst værdi (se <a href=\"http://www.cs.tufts.edu/comp/150IR/labs/wavefront.html\" target=\"_blank\" rel=\"noopener noreferrer\">Wavefront planner</a>).</p>\n<h2 id=\"implementering\">Implementering</h2>\n<p>Du kan se den komplette kildekode til programmet her: <a href=\"/code/main.c\" rel=\"noopener noreferrer\">main.c</a>.\nKoden burde være rimelig selvbeskrivende og letforståelig.</p>\n<h2 id=\"test\">Test</h2>\n<p><a href=\"/static/media/2014-10-04_171902.pgm\"><img src=\"/static/media/2014-10-04_171902.png\" alt=\"Korteste vej\" style=\"display:block;width:50%;margin:0 auto;\"></a>\nJeg har selv kompileret programmet med</p>\n<pre><code>gcc -Wall -std=c89 -pedantic main.c -o main</code></pre>\n<p>(jeg følger C89 kode-standarden) og køres med</p>\n<pre><code>./main &lt;inputfil&gt; &lt;startx&gt; &lt;starty&gt; &lt;slutx&gt; &lt;sluty&gt; [&lt;tolerance&gt;]</code></pre>\n<p>hvor <code>tolerance</code> er et valgfrit argument (har standardværdi $0$).</p>\n<p>Kørsel af programmet giver</p>\n<pre><code>$ ./main labyrinth.pgm 9 85 832 874\nwavefront(img, (9,85), (832,874))\nwavefront finished\n=&gt; Distance from (9,85) to (832,874) is 7182</code></pre>\n<p>og producerer ovenstående sti fra start (øveste venstre hjørne) til slut-punket\ni nederste højre hjørne.</p>\n<h2 id=\"konklusion\">Konklusion</h2>\n<p>Jeg har helt sikkert brugt meget længere tid på dette relativt lille og simple\nprojekt end nødvendigt; men det har været sjovt at rode lidt rundt i <code>C</code> igen,\nog jeg fandt det yderst tilfredsstillende at arbejde med <code>.pgm</code> filformatet for\ndets dejlige enkelthed.</p>\n<p>Jeg har ikke rigtig tunet programmet til at have nogen fantastisk køretid,\nså det er sikkert langt fra optimalt. Men køretiden på\n<a href=\"/static/media/labyrinth.pgm\" rel=\"noopener noreferrer\">denne inputfil</a>\nmed $796500$ billedepunkter ($900\\times885\\text{ px}$) er $\\approx0.232s$:</p>\n<pre><code>$ time ./main labyrinth.pgm 9 85 832 874\nreal    0m0.255s\nuser    0m0.232s\nsys     0m0.020s</code></pre>\n","excerpt":"En stille torsdag aften blev pludselig dedikeret til implementeringen af\nwavefront algoritmen til at finde korteste vej gennem et diskret arbejdsrum\nmed forhindringer; dvs. fx en labyrint repræsenteret i et billede.","title":"Wavefront Implementation","author":"Casper Kehlet Jensen","description":"Implementation af wavefront algoritmen til at finde en vej gennem et diskret arbejdsrum med forhindringer.","warning":"Døde links!","draft":false,"published":{"year":2014,"month":10,"date":4,"timestamp":"2014-10-04"},"hide":false,"gallery_name":null,"gallery_position":"top","gallery":null}