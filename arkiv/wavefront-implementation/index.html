<!DOCTYPE html> <html lang=da> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <base href=/ > <link href=manifest.json rel=manifest> <meta content=#358724 name=theme-color> <link href=favicon.ico rel=icon type=image/x-icon> <link href=/main.css rel=stylesheet> <link href=/normalize.css rel=stylesheet> <style>main.svelte-1jtvvyh.svelte-1jtvvyh{flex:1 1 auto;background:rgba(0,0,0,.125)}.container.svelte-1jtvvyh.svelte-1jtvvyh{width:100%;margin:0 auto;padding:20px;max-width:800px;box-sizing:border-box}main.svelte-1jtvvyh .container.svelte-1jtvvyh{border:2px solid rgba(0,0,0,.5);border-top:none;background:#fff;margin-bottom:calc((100vw - 800px)/ 2)}header .container.svelte-1jtvvyh.svelte-1jtvvyh{background:rgba(0,0,0,.75)}.images-wrapper.svelte-1jtvvyh.svelte-1jtvvyh{top:0;left:0;width:100%;height:100%;z-index:1;position:absolute}.typer-wrapper.svelte-1jtvvyh.svelte-1jtvvyh{position:relative;z-index:100}@media(max-width:800px){main.svelte-1jtvvyh .container.svelte-1jtvvyh{margin-bottom:0}header .container.svelte-1jtvvyh.svelte-1jtvvyh{padding:10px}}header.svelte-132eyxn.svelte-132eyxn{display:flex;position:relative;box-sizing:border-box;padding-top:10px;align-items:start;justify-content:start}nav.svelte-132eyxn.svelte-132eyxn{top:0;width:100%;z-index:100;position:fixed;overflow:hidden;background:#fff;box-sizing:border-box;border-top:3px solid #59c14b;line-height:44px;padding-left:calc((100vw - 100%));border-bottom:3px solid #358724;background:#59c14b;background:linear-gradient(90deg,#59c14b 0,#59c14b 50%,#358724 50%,#358724 100%)}nav.svelte-132eyxn .container.svelte-132eyxn{width:100%;margin:0 auto;display:flex;padding:0 20px;max-width:800px;box-sizing:border-box;background:#59c14b;background:-moz-linear-gradient(45deg,#59c14b 0,#59c14b 50%,#358724 50%,#358724 100%);background:-webkit-linear-gradient(45deg,#59c14b 0,#59c14b 50%,#358724 50%,#358724 100%);background:linear-gradient(45deg,#59c14b 0,#59c14b 50%,#358724 50%,#358724 100%)}nav.svelte-132eyxn ul.svelte-132eyxn{margin:0 -10px 0 auto;display:flex;list-style:none;justify-content:space-between}nav.svelte-132eyxn ul li.svelte-132eyxn{line-height:inherit}nav.svelte-132eyxn ul li a.svelte-132eyxn{color:#222;padding:0 10px;font-size:16px;transition:color .2s ease-in-out;text-decoration:none}nav.svelte-132eyxn ul li a.svelte-132eyxn:focus,nav.svelte-132eyxn ul li a.svelte-132eyxn:hover{color:#000;text-decoration:underline}nav.svelte-132eyxn h1.svelte-132eyxn{margin:0;font-size:24px}nav.svelte-132eyxn h1 a.svelte-132eyxn{color:inherit;text-decoration:none}@media(max-width:500px){nav.svelte-132eyxn h1.svelte-132eyxn{font-size:20px}nav.svelte-132eyxn ul li a.svelte-132eyxn{font-size:14px}}.post-gallery.svelte-1rat90s{margin:25px 0}.wrapper.svelte-1yce3id{width:80%;border:2px solid #358724;display:flex;padding:8px 20px;background:#59c14b;align-items:center;border-left:none;margin-left:-20px;border-top-right-radius:128px;border-bottom-right-radius:128px}.me.svelte-1yce3id{flex:0 0 auto;width:100px;height:100px;border:3px solid #fff;margin:0 -11px 0 11px;border-radius:50%;background:#fff;background-size:100%;background-image:url(/img/components/me/me2.jpg)}.link-btn.svelte-1yce3id{color:#eee;margin:0;cursor:pointer;border:none;padding:0;outline:0;display:inline;background:0 0;text-decoration:underline}.link-btn.svelte-1yce3id:focus,.link-btn.svelte-1yce3id:hover{color:#fff}.obfuscated.svelte-1yce3id{unicode-bidi:bidi-override;direction:rtl}@media(max-width:500px){.wrapper.svelte-1yce3id{width:90%}}</style> <title>Wavefront Implementation</title><meta content="Implementation af wavefront algoritmen til at finde en vej gennem et diskret arbejdsrum med forhindringer." name=Description> <link href=/client/client.cb032e34.css rel=preload as=style><link href=/client/Post.c2293b94.css rel=preload as=style><link href=/client/Me.fb9a73a2.css rel=preload as=style></head> <body> <div id=sapper> <header class=svelte-132eyxn style=height:50px></header> <nav class=svelte-132eyxn style=transform:translateY(0);height:50px><div class="svelte-132eyxn container"><h1 class=svelte-132eyxn><a href=/ class=svelte-132eyxn>snemanden.com</a></h1> <ul class=svelte-132eyxn><li class=svelte-132eyxn><a href=/blog rel=prefetch class=svelte-132eyxn>blog</a></li> <li class=svelte-132eyxn><a href=/om class=svelte-132eyxn>om</a></li> <li class=svelte-132eyxn><a href=/arkiv rel=prefetch class=svelte-132eyxn>arkiv</a></ul></div> </nav> <main class=svelte-1jtvvyh><div class="container svelte-1jtvvyh"> <article><header><h1>Wavefront Implementation</h1> <div class=right><div class=timestamp>2014-10-04</div> <div class=warning>Døde links!</div></div></header> <section><p>En stille torsdag aften blev pludselig dedikeret til implementeringen af wavefront algoritmen til at finde korteste vej gennem et diskret arbejdsrum med forhindringer; dvs. fx en labyrint repræsenteret i et billede.</p> <h2 id=specifikation>Specifikation</h2> <p>Mikkel, robotteknologi-studerende, havde i et kursus fået en sjov lille opgave; de skulle implementere wavefront algoritmen i <code>C++</code> og finde den korteste vej gennem en labyrint i en billedefil ud fra et start og ende punkt. Jeg syntes opgaven lød meget sjov, så jeg valgte at lave min egen implementering i <code>C</code>.</p> <p><a href=/static/media/labyrinth.pgm><img alt="Korteste vej" src=/static/media/labyrinth.png style="display:block;width:50%;margin:0 auto"></a></p> <p>Den udleverede labyrint er repræsenteret som en <code>.pgm</code> fil: et <a href=http://netpbm.sourceforge.net/doc/pgm.html rel="noopener noreferrer" target=_blank>simpelt gråtone billedeformat</a>. Det indeholder et "magisk nummer" (version/format), bredde, højde og maxværdi for gråtone. Dernæst følger $\text{bredde} \cdot \text{højde}$ værdier repræsenterende den $i$te pixels gråtone: $0=\text{sort}$, $maxval=\text{hvid}$. ($i$te pixel fra øverste venstre til nederste højre hjørne.)</p> <h2 id=design>Design</h2> <p>Programmet starter med at parse billedefilen; læse headeren og dernæst opbygge et lineært array af $\text{bredde} \cdot \text{højde}$ punkter; som alt efter den valgte tolerance får værdien $0$ hvis pixlen er fri eller $1$ hvis det er en forhindring. Hvert punkt har også et array på fire <code>integers</code> repræsenterende index'et til punktets naboer (forstået som en pointer). </p> <p>Dernæst udføres wavefront algoritmen. Pseudokoden for min implementering er</p> <pre><code>wavefront(image, start, slut)
    skridt = 0
    queue = ny tom kø
    læg slut-punktet i queue og tildel det værdien 2

    while (køen har elementer)
        elm = udtræk første element i køen
        for (hver nabo til elm)
            if (nabo findes OG nabo er fri)
                nabo.value = elm.value + 1
                læg nabo i køen
        skridt = skridt+1
    return skridt</code></pre> <p>Køretiden for denne algoritme er $O(n\cdot m)$ for $n=\text{bredde}$ og $m=\text{højde}$ af billedet.</p> <p>Når wavefront algoritmen er anvendt på billedet, findes den korteste vej nemt, ved blot at starte i start-punktet, og følge stien til mål ved at gå i den retning som har mindst værdi (se <a href=http://www.cs.tufts.edu/comp/150IR/labs/wavefront.html rel="noopener noreferrer" target=_blank>Wavefront planner</a>).</p> <h2 id=implementering>Implementering</h2> <p>Du kan se den komplette kildekode til programmet her: <a href=/code/main.c rel="noopener noreferrer">main.c</a>. Koden burde være rimelig selvbeskrivende og letforståelig.</p> <h2 id=test>Test</h2> <p><a href=/static/media/2014-10-04_171902.pgm><img alt="Korteste vej" src=/static/media/2014-10-04_171902.png style="display:block;width:50%;margin:0 auto"></a> Jeg har selv kompileret programmet med</p> <pre><code>gcc -Wall -std=c89 -pedantic main.c -o main</code></pre> <p>(jeg følger C89 kode-standarden) og køres med</p> <pre><code>./main &lt;inputfil> &lt;startx> &lt;starty> &lt;slutx> &lt;sluty> [&lt;tolerance>]</code></pre> <p>hvor <code>tolerance</code> er et valgfrit argument (har standardværdi $0$).</p> <p>Kørsel af programmet giver</p> <pre><code>$ ./main labyrinth.pgm 9 85 832 874
wavefront(img, (9,85), (832,874))
wavefront finished
=> Distance from (9,85) to (832,874) is 7182</code></pre> <p>og producerer ovenstående sti fra start (øveste venstre hjørne) til slut-punket i nederste højre hjørne.</p> <h2 id=konklusion>Konklusion</h2> <p>Jeg har helt sikkert brugt meget længere tid på dette relativt lille og simple projekt end nødvendigt; men det har været sjovt at rode lidt rundt i <code>C</code> igen, og jeg fandt det yderst tilfredsstillende at arbejde med <code>.pgm</code> filformatet for dets dejlige enkelthed.</p> <p>Jeg har ikke rigtig tunet programmet til at have nogen fantastisk køretid, så det er sikkert langt fra optimalt. Men køretiden på <a href=/static/media/labyrinth.pgm rel="noopener noreferrer">denne inputfil</a> med $796500$ billedepunkter ($900\times885\text{ px}$) er $\approx0.232s$:</p> <pre><code>$ time ./main labyrinth.pgm 9 85 832 874
real    0m0.255s
user    0m0.232s
sys     0m0.020s</code></pre> </section> <footer><div class="svelte-1yce3id wrapper"><div class=note><p>Tak fordi du læste med. </p> <p>Hvis du har kommentarer til indlægget, er du velkommen til at skrive en mail til mig på: <button class="svelte-1yce3id link-btn obfuscated">moc.nednamens@tkatnok </button>. </div> <div class="svelte-1yce3id me"></div> </div></footer> </article></div> </main> </div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a,b){return {post:{slug:"wavefront-implementation",html:"\u003Cp\u003EEn stille torsdag aften blev pludselig dedikeret til implementeringen af\nwavefront algoritmen til at finde korteste vej gennem et diskret arbejdsrum\nmed forhindringer; dvs. fx en labyrint repræsenteret i et billede.\u003C\u002Fp\u003E\n\u003Ch2 id=\"specifikation\"\u003ESpecifikation\u003C\u002Fh2\u003E\n\u003Cp\u003EMikkel, robotteknologi-studerende, havde i et kursus fået en sjov lille opgave;\nde skulle implementere wavefront algoritmen i \u003Ccode\u003EC++\u003C\u002Fcode\u003E og finde den korteste vej\ngennem en labyrint i en billedefil ud fra et start og ende punkt.\nJeg syntes opgaven lød meget sjov, så jeg valgte at lave min egen implementering\ni \u003Ccode\u003EC\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"\u002Fstatic\u002Fmedia\u002Flabyrinth.pgm\"\u003E\u003Cimg src=\"\u002Fstatic\u002Fmedia\u002Flabyrinth.png\" alt=\"Korteste vej\" style=\"display:block;width:50%;margin:0 auto;\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EDen udleverede labyrint er repræsenteret som en \u003Ccode\u003E.pgm\u003C\u002Fcode\u003E fil: et\n\u003Ca href=\"http:\u002F\u002Fnetpbm.sourceforge.net\u002Fdoc\u002Fpgm.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003Esimpelt gråtone billedeformat\u003C\u002Fa\u003E.\nDet indeholder et &quot;magisk nummer&quot; (version\u002Fformat), bredde, højde og maxværdi\nfor gråtone. Dernæst følger $\\text{bredde} \\cdot \\text{højde}$ værdier\nrepræsenterende den $i$te pixels gråtone: $0=\\text{sort}$, $maxval=\\text{hvid}$.\n($i$te pixel fra øverste venstre til nederste højre hjørne.)\u003C\u002Fp\u003E\n\u003Ch2 id=\"design\"\u003EDesign\u003C\u002Fh2\u003E\n\u003Cp\u003EProgrammet starter med at parse billedefilen; læse headeren og dernæst opbygge\net lineært array af $\\text{bredde} \\cdot \\text{højde}$ punkter; som alt efter\nden valgte tolerance får værdien $0$ hvis pixlen er fri eller $1$ hvis det er\nen forhindring.\nHvert punkt har også et array på fire \u003Ccode\u003Eintegers\u003C\u002Fcode\u003E repræsenterende index&#39;et til\npunktets naboer (forstået som en pointer). \u003C\u002Fp\u003E\n\u003Cp\u003EDernæst udføres wavefront algoritmen. Pseudokoden for min implementering er\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Ewavefront(image, start, slut)\n    skridt = 0\n    queue = ny tom kø\n    læg slut-punktet i queue og tildel det værdien 2\n\n    while (køen har elementer)\n        elm = udtræk første element i køen\n        for (hver nabo til elm)\n            if (nabo findes OG nabo er fri)\n                nabo.value = elm.value + 1\n                læg nabo i køen\n        skridt = skridt+1\n    return skridt\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EKøretiden for denne algoritme er $O(n\\cdot m)$ for $n=\\text{bredde}$ og\n$m=\\text{højde}$ af billedet.\u003C\u002Fp\u003E\n\u003Cp\u003ENår wavefront algoritmen er anvendt på billedet, findes den korteste vej nemt,\nved blot at starte i start-punktet, og følge stien til mål ved at gå i den\nretning som har mindst værdi (se \u003Ca href=\"http:\u002F\u002Fwww.cs.tufts.edu\u002Fcomp\u002F150IR\u002Flabs\u002Fwavefront.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003EWavefront planner\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\n\u003Ch2 id=\"implementering\"\u003EImplementering\u003C\u002Fh2\u003E\n\u003Cp\u003EDu kan se den komplette kildekode til programmet her: \u003Ca href=\"\u002Fcode\u002Fmain.c\" rel=\"noopener noreferrer\"\u003Emain.c\u003C\u002Fa\u003E.\nKoden burde være rimelig selvbeskrivende og letforståelig.\u003C\u002Fp\u003E\n\u003Ch2 id=\"test\"\u003ETest\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"\u002Fstatic\u002Fmedia\u002F2014-10-04_171902.pgm\"\u003E\u003Cimg src=\"\u002Fstatic\u002Fmedia\u002F2014-10-04_171902.png\" alt=\"Korteste vej\" style=\"display:block;width:50%;margin:0 auto;\"\u003E\u003C\u002Fa\u003E\nJeg har selv kompileret programmet med\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Egcc -Wall -std=c89 -pedantic main.c -o main\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E(jeg følger C89 kode-standarden) og køres med\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E.\u002Fmain &lt;inputfil&gt; &lt;startx&gt; &lt;starty&gt; &lt;slutx&gt; &lt;sluty&gt; [&lt;tolerance&gt;]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Ehvor \u003Ccode\u003Etolerance\u003C\u002Fcode\u003E er et valgfrit argument (har standardværdi $0$).\u003C\u002Fp\u003E\n\u003Cp\u003EKørsel af programmet giver\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$ .\u002Fmain labyrinth.pgm 9 85 832 874\nwavefront(img, (9,85), (832,874))\nwavefront finished\n=&gt; Distance from (9,85) to (832,874) is 7182\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eog producerer ovenstående sti fra start (øveste venstre hjørne) til slut-punket\ni nederste højre hjørne.\u003C\u002Fp\u003E\n\u003Ch2 id=\"konklusion\"\u003EKonklusion\u003C\u002Fh2\u003E\n\u003Cp\u003EJeg har helt sikkert brugt meget længere tid på dette relativt lille og simple\nprojekt end nødvendigt; men det har været sjovt at rode lidt rundt i \u003Ccode\u003EC\u003C\u002Fcode\u003E igen,\nog jeg fandt det yderst tilfredsstillende at arbejde med \u003Ccode\u003E.pgm\u003C\u002Fcode\u003E filformatet for\ndets dejlige enkelthed.\u003C\u002Fp\u003E\n\u003Cp\u003EJeg har ikke rigtig tunet programmet til at have nogen fantastisk køretid,\nså det er sikkert langt fra optimalt. Men køretiden på\n\u003Ca href=\"\u002Fstatic\u002Fmedia\u002Flabyrinth.pgm\" rel=\"noopener noreferrer\"\u003Edenne inputfil\u003C\u002Fa\u003E\nmed $796500$ billedepunkter ($900\\times885\\text{ px}$) er $\\approx0.232s$:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$ time .\u002Fmain labyrinth.pgm 9 85 832 874\nreal    0m0.255s\nuser    0m0.232s\nsys     0m0.020s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n",excerpt:"En stille torsdag aften blev pludselig dedikeret til implementeringen af\nwavefront algoritmen til at finde korteste vej gennem et diskret arbejdsrum\nmed forhindringer; dvs. fx en labyrint repræsenteret i et billede.",title:"Wavefront Implementation",author:"Casper Kehlet Jensen",description:"Implementation af wavefront algoritmen til at finde en vej gennem et diskret arbejdsrum med forhindringer.",warning:"Døde links!",draft:a,published:{year:2014,month:10,date:4,timestamp:"2014-10-04"},hide:a,gallery_name:b,gallery_position:"top",gallery:b}}}(false,null))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.cb032e34.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.cb032e34.js")}document.head.appendChild(s)</script> 